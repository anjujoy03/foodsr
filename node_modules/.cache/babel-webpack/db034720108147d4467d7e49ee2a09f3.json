{"ast":null,"code":"import { CommonModule } from '@angular/common';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { __awaiter } from 'tslib';\nimport { BrowserMultiFormatReader, BrowserCodeReader } from '@zxing/browser';\nimport { NotFoundException, ChecksumException, FormatException, BarcodeFormat, DecodeHintType } from '@zxing/library';\nimport { BehaviorSubject } from 'rxjs';\n/**\n * Based on zxing-typescript BrowserCodeReader\n */\n\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"preview\"];\n\nclass BrowserMultiFormatContinuousReader extends BrowserMultiFormatReader {\n  /**\n   * Returns the code reader scanner controls.\n   */\n  getScannerControls() {\n    if (!this.scannerControls) {\n      throw new Error('No scanning is running at the time.');\n    }\n\n    return this.scannerControls;\n  }\n  /**\n   * Starts the decoding from the current or a new video element.\n   *\n   * @param deviceId The device's to be used Id\n   * @param previewEl A new video element\n   */\n\n\n  scanFromDeviceObservable(deviceId, previewEl) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const scan$ = new BehaviorSubject({});\n      let ctrls;\n\n      try {\n        ctrls = yield this.decodeFromVideoDevice(deviceId, previewEl, (result, error) => {\n          if (!error) {\n            scan$.next({\n              result\n            });\n            return;\n          }\n\n          const errorName = error.name; // stream cannot stop on fails.\n\n          if ( // scan Failure - found nothing, no error\n          errorName === NotFoundException.name || // scan Error - found the QR but got error on decoding\n          errorName === ChecksumException.name || errorName === FormatException.name || error.message.includes('No MultiFormat Readers were able to detect the code.')) {\n            scan$.next({\n              error\n            });\n            return;\n          } // probably fatal error\n\n\n          scan$.error(error);\n          this.scannerControls.stop();\n          this.scannerControls = undefined;\n          return;\n        });\n        this.scannerControls = Object.assign(Object.assign({}, ctrls), {\n          stop() {\n            ctrls.stop();\n            scan$.complete();\n          }\n\n        });\n      } catch (e) {\n        scan$.error(e);\n        (_a = this.scannerControls) === null || _a === void 0 ? void 0 : _a.stop();\n        this.scannerControls = undefined;\n      }\n\n      return scan$.asObservable();\n    });\n  }\n\n}\n\nlet ZXingScannerComponent = /*#__PURE__*/(() => {\n  class ZXingScannerComponent {\n    /**\n     * Constructor to build the object and do some DI.\n     */\n    constructor() {\n      /**\n       * Delay between attempts to decode (default is 500ms)\n       */\n      this.timeBetweenScans = 500;\n      /**\n       * Delay between successful decode (default is 500ms)\n       */\n\n      this.delayBetweenScanSuccess = 500;\n      /**\n       * How the preview element shoud be fit inside the :host container.\n       */\n\n      this.previewFitMode = 'cover';\n      this._ready = false; // instance based emitters\n\n      this.autostarted = new EventEmitter();\n      this.autostarting = new EventEmitter();\n      this.torchCompatible = new EventEmitter(false);\n      this.scanSuccess = new EventEmitter();\n      this.scanFailure = new EventEmitter();\n      this.scanError = new EventEmitter();\n      this.scanComplete = new EventEmitter();\n      this.camerasFound = new EventEmitter();\n      this.camerasNotFound = new EventEmitter();\n      this.permissionResponse = new EventEmitter(true);\n      this.hasDevices = new EventEmitter();\n      this.deviceChange = new EventEmitter();\n      this._enabled = true;\n      this._hints = new Map();\n      this.autofocusEnabled = true;\n      this.autostart = true;\n      this.formats = [BarcodeFormat.QR_CODE]; // computed data\n\n      this.hasNavigator = typeof navigator !== 'undefined';\n      this.isMediaDevicesSupported = this.hasNavigator && !!navigator.mediaDevices;\n    }\n    /**\n     * Exposes the current code reader, so the user can use it's APIs.\n     */\n\n\n    get codeReader() {\n      return this._codeReader;\n    }\n    /**\n     * User device input\n     */\n\n\n    set device(device) {\n      if (!this._ready) {\n        this._devicePreStart = device; // let's ignore silently, users don't liek logs\n\n        return;\n      }\n\n      if (this.isAutostarting) {\n        // do not allow setting devices during auto-start, since it will set one and emit it.\n        console.warn('Avoid setting a device during auto-start.');\n        return;\n      }\n\n      if (this.isCurrentDevice(device)) {\n        console.warn('Setting the same device is not allowed.');\n        return;\n      }\n\n      if (!this.hasPermission) {\n        console.warn('Permissions not set yet, waiting for them to be set to apply device change.'); // this.permissionResponse\n        //   .pipe(\n        //     take(1),\n        //     tap(() => console.log(`Permissions set, applying device change${device ? ` (${device.deviceId})` : ''}.`))\n        //   )\n        //   .subscribe(() => this.device = device);\n\n        return;\n      }\n\n      this.setDevice(device);\n    }\n    /**\n     * User device acessor.\n     */\n\n\n    get device() {\n      return this._device;\n    }\n    /**\n     * Returns all the registered formats.\n     */\n\n\n    get formats() {\n      return this.hints.get(DecodeHintType.POSSIBLE_FORMATS);\n    }\n    /**\n     * Registers formats the scanner should support.\n     *\n     * @param input BarcodeFormat or case-insensitive string array.\n     */\n\n\n    set formats(input) {\n      if (typeof input === 'string') {\n        throw new Error('Invalid formats, make sure the [formats] input is a binding.');\n      } // formats may be set from html template as BarcodeFormat or string array\n\n\n      const formats = input.map(f => this.getBarcodeFormatOrFail(f));\n      const hints = this.hints; // updates the hints\n\n      hints.set(DecodeHintType.POSSIBLE_FORMATS, formats); // handles updating the codeReader\n\n      this.hints = hints;\n    }\n    /**\n     * Returns all the registered hints.\n     */\n\n\n    get hints() {\n      return this._hints;\n    }\n    /**\n     * Does what it takes to set the hints.\n     */\n\n\n    set hints(hints) {\n      var _a;\n\n      this._hints = hints; // new instance with new hints.\n\n      (_a = this.codeReader) === null || _a === void 0 ? void 0 : _a.setHints(this._hints);\n    }\n    /**\n     * Sets the desired constraints in all video tracks.\n     * @experimental\n     */\n\n\n    set videoConstraints(constraints) {\n      var _a; // new instance with new hints.\n\n\n      const controls = (_a = this.codeReader) === null || _a === void 0 ? void 0 : _a.getScannerControls();\n\n      if (!controls) {\n        // fails silently\n        return;\n      }\n\n      controls === null || controls === void 0 ? void 0 : controls.streamVideoConstraintsApply(constraints);\n    }\n    /**\n     *\n     */\n\n\n    set isAutostarting(state) {\n      this._isAutostarting = state;\n      this.autostarting.next(state);\n    }\n    /**\n     *\n     */\n\n\n    get isAutostarting() {\n      return this._isAutostarting;\n    }\n    /**\n     * Can turn on/off the device flashlight.\n     *\n     * @experimental Torch/Flash APIs are not stable in all browsers, it may be buggy!\n     */\n\n\n    set torch(onOff) {\n      try {\n        const controls = this.getCodeReader().getScannerControls();\n        controls.switchTorch(onOff);\n      } catch (error) {// ignore error\n      }\n    }\n    /**\n     * Starts and Stops the scanning.\n     */\n\n\n    set enable(enabled) {\n      this._enabled = Boolean(enabled);\n\n      if (!this._enabled) {\n        this.reset();\n      } else {\n        if (this.device) {\n          this.scanFromDevice(this.device.deviceId);\n        } else {\n          this.init();\n        }\n      }\n    }\n    /**\n     * Tells if the scanner is enabled or not.\n     */\n\n\n    get enabled() {\n      return this._enabled;\n    }\n    /**\n     * If is `tryHarder` enabled.\n     */\n\n\n    get tryHarder() {\n      return this.hints.get(DecodeHintType.TRY_HARDER);\n    }\n    /**\n     * Enable/disable tryHarder hint.\n     */\n\n\n    set tryHarder(enable) {\n      const hints = this.hints;\n\n      if (enable) {\n        hints.set(DecodeHintType.TRY_HARDER, true);\n      } else {\n        hints.delete(DecodeHintType.TRY_HARDER);\n      }\n\n      this.hints = hints;\n    }\n    /**\n     * Gets and registers all cammeras.\n     */\n\n\n    askForPermission() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!this.hasNavigator) {\n          console.error('@zxing/ngx-scanner', 'Can\\'t ask permission, navigator is not present.');\n          this.setPermission(null);\n          return this.hasPermission;\n        }\n\n        if (!this.isMediaDevicesSupported) {\n          console.error('@zxing/ngx-scanner', 'Can\\'t get user media, this is not supported.');\n          this.setPermission(null);\n          return this.hasPermission;\n        }\n\n        let stream;\n        let permission;\n\n        try {\n          // Will try to ask for permission\n          stream = yield this.getAnyVideoDevice();\n          permission = !!stream;\n        } catch (err) {\n          return this.handlePermissionException(err);\n        } finally {\n          this.terminateStream(stream);\n        }\n\n        this.setPermission(permission); // Returns the permission\n\n        return permission;\n      });\n    }\n    /**\n     *\n     */\n\n\n    getAnyVideoDevice() {\n      return navigator.mediaDevices.getUserMedia({\n        video: true\n      });\n    }\n    /**\n     * Terminates a stream and it's tracks.\n     */\n\n\n    terminateStream(stream) {\n      if (stream) {\n        stream.getTracks().forEach(t => t.stop());\n      }\n\n      stream = undefined;\n    }\n\n    init() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!this.autostart) {\n          console.warn('Feature \\'autostart\\' disabled. Permissions and devices recovery has to be run manually.'); // does the necessary configuration without autostarting\n\n          this.initAutostartOff();\n          this._ready = true;\n          return;\n        } // configurates the component and starts the scanner\n\n\n        yield this.initAutostartOn();\n        this._ready = true;\n      });\n    }\n    /**\n     * Initializes the component without starting the scanner.\n     */\n\n\n    initAutostartOff() {\n      // do not ask for permission when autostart is off\n      this.isAutostarting = false; // just update devices information\n\n      this.updateVideoInputDevices();\n\n      if (this._device && this._devicePreStart) {\n        this.setDevice(this._devicePreStart);\n      }\n    }\n    /**\n     * Initializes the component and starts the scanner.\n     * Permissions are asked to accomplish that.\n     */\n\n\n    initAutostartOn() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.isAutostarting = true;\n        let hasPermission;\n\n        try {\n          // Asks for permission before enumerating devices so it can get all the device's info\n          hasPermission = yield this.askForPermission();\n        } catch (e) {\n          console.error('Exception occurred while asking for permission:', e);\n          return;\n        } // from this point, things gonna need permissions\n\n\n        if (hasPermission) {\n          const devices = yield this.updateVideoInputDevices();\n          yield this.autostartScanner([...devices]);\n        }\n\n        this.isAutostarting = false;\n        this.autostarted.next();\n      });\n    }\n    /**\n     * Checks if the given device is the current defined one.\n     */\n\n\n    isCurrentDevice(device) {\n      var _a;\n\n      return (device === null || device === void 0 ? void 0 : device.deviceId) === ((_a = this._device) === null || _a === void 0 ? void 0 : _a.deviceId);\n    }\n    /**\n     * Executes some actions before destroy the component.\n     */\n\n\n    ngOnDestroy() {\n      this.reset();\n    }\n    /**\n     *\n     */\n\n\n    ngOnInit() {\n      this.init();\n    }\n    /**\n     * Stops the scanning, if any.\n     */\n\n\n    scanStop() {\n      var _a, _b;\n\n      if (this._scanSubscription) {\n        (_a = this.codeReader) === null || _a === void 0 ? void 0 : _a.getScannerControls().stop();\n        (_b = this._scanSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();\n        this._scanSubscription = undefined;\n      }\n\n      this.torchCompatible.next(false);\n    }\n    /**\n     * Stops the scanning, if any.\n     */\n\n\n    scanStart() {\n      if (this._scanSubscription) {\n        throw new Error('There is already a scan proccess running.');\n      }\n\n      if (!this._device) {\n        throw new Error('No device defined, cannot start scan, please define a device.');\n      }\n\n      this.scanFromDevice(this._device.deviceId);\n    }\n    /**\n     * Stops old `codeReader` and starts scanning in a new one.\n     */\n\n\n    restart() {\n      // @note apenas necessario por enquanto causa da Torch\n      this._codeReader = undefined;\n\n      const prevDevice = this._reset();\n\n      if (!prevDevice) {\n        return;\n      }\n\n      this.device = prevDevice;\n    }\n    /**\n     * Discovers and updates known video input devices.\n     */\n\n\n    updateVideoInputDevices() {\n      return __awaiter(this, void 0, void 0, function* () {\n        // permissions aren't needed to get devices, but to access them and their info\n        const devices = (yield BrowserCodeReader.listVideoInputDevices()) || [];\n        const hasDevices = devices && devices.length > 0; // stores discovered devices and updates information\n\n        this.hasDevices.next(hasDevices);\n        this.camerasFound.next([...devices]);\n\n        if (!hasDevices) {\n          this.camerasNotFound.next();\n        }\n\n        return devices;\n      });\n    }\n    /**\n     * Starts the scanner with the back camera otherwise take the last\n     * available device.\n     */\n\n\n    autostartScanner(devices) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const matcher = ({\n          label\n        }) => /back|trás|rear|traseira|environment|ambiente/gi.test(label); // select the rear camera by default, otherwise take the last camera.\n\n\n        const device = devices.find(matcher) || devices.pop();\n\n        if (!device) {\n          throw new Error('Impossible to autostart, no input devices available.');\n        }\n\n        yield this.setDevice(device);\n        this.deviceChange.next(device);\n      });\n    }\n    /**\n     * Dispatches the scan success event.\n     *\n     * @param result the scan result.\n     */\n\n\n    dispatchScanSuccess(result) {\n      this.scanSuccess.next(result.getText());\n    }\n    /**\n     * Dispatches the scan failure event.\n     */\n\n\n    dispatchScanFailure(reason) {\n      this.scanFailure.next(reason);\n    }\n    /**\n     * Dispatches the scan error event.\n     *\n     * @param error the error thing.\n     */\n\n\n    dispatchScanError(error) {\n      if (!this.scanError.observers.some(x => Boolean(x))) {\n        console.error(`zxing scanner component: ${error.name}`, error);\n        console.warn('Use the `(scanError)` property to handle errors like this!');\n      }\n\n      this.scanError.next(error);\n    }\n    /**\n     * Dispatches the scan event.\n     *\n     * @param result the scan result.\n     */\n\n\n    dispatchScanComplete(result) {\n      this.scanComplete.next(result);\n    }\n    /**\n     * Returns the filtered permission.\n     */\n\n\n    handlePermissionException(err) {\n      // failed to grant permission to video input\n      console.error('@zxing/ngx-scanner', 'Error when asking for permission.', err);\n      let permission;\n\n      switch (err.name) {\n        // usually caused by not secure origins\n        case 'NotSupportedError':\n          console.warn('@zxing/ngx-scanner', err.message); // could not claim\n\n          permission = null; // can't check devices\n\n          this.hasDevices.next(null);\n          break;\n        // user denied permission\n\n        case 'NotAllowedError':\n          console.warn('@zxing/ngx-scanner', err.message); // claimed and denied permission\n\n          permission = false; // this means that input devices exists\n\n          this.hasDevices.next(true);\n          break;\n        // the device has no attached input devices\n\n        case 'NotFoundError':\n          console.warn('@zxing/ngx-scanner', err.message); // no permissions claimed\n\n          permission = null; // because there was no devices\n\n          this.hasDevices.next(false); // tells the listener about the error\n\n          this.camerasNotFound.next(err);\n          break;\n\n        case 'NotReadableError':\n          console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.'); // no permissions claimed\n\n          permission = null; // there are devices, which I couldn't use\n\n          this.hasDevices.next(false); // tells the listener about the error\n\n          this.camerasNotFound.next(err);\n          break;\n\n        default:\n          console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err); // unknown\n\n          permission = null; // this.hasDevices.next(undefined;\n\n          break;\n      }\n\n      this.setPermission(permission); // tells the listener about the error\n\n      this.permissionResponse.error(err);\n      return permission;\n    }\n    /**\n     * Returns a valid BarcodeFormat or fails.\n     */\n\n\n    getBarcodeFormatOrFail(format) {\n      return typeof format === 'string' ? BarcodeFormat[format.trim().toUpperCase()] : format;\n    }\n    /**\n     * Retorna um code reader, cria um se nenhume existe.\n     */\n\n\n    getCodeReader() {\n      if (!this._codeReader) {\n        const options = {\n          delayBetweenScanAttempts: this.timeBetweenScans,\n          delayBetweenScanSuccess: this.delayBetweenScanSuccess\n        };\n        this._codeReader = new BrowserMultiFormatContinuousReader(this.hints, options);\n      }\n\n      return this._codeReader;\n    }\n    /**\n     * Starts the continuous scanning for the given device.\n     *\n     * @param deviceId The deviceId from the device.\n     */\n\n\n    scanFromDevice(deviceId) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const videoElement = this.previewElemRef.nativeElement;\n        const codeReader = this.getCodeReader();\n        const scanStream = yield codeReader.scanFromDeviceObservable(deviceId, videoElement);\n\n        if (!scanStream) {\n          throw new Error('Undefined decoding stream, aborting.');\n        }\n\n        const next = x => this._onDecodeResult(x.result, x.error);\n\n        const error = err => this._onDecodeError(err);\n\n        const complete = () => {};\n\n        this._scanSubscription = scanStream.subscribe(next, error, complete);\n\n        if (this._scanSubscription.closed) {\n          return;\n        }\n\n        const controls = codeReader.getScannerControls();\n        const hasTorchControl = typeof controls.switchTorch !== 'undefined';\n        this.torchCompatible.next(hasTorchControl);\n      });\n    }\n    /**\n     * Handles decode errors.\n     */\n\n\n    _onDecodeError(err) {\n      this.dispatchScanError(err); // this.reset();\n    }\n    /**\n     * Handles decode results.\n     */\n\n\n    _onDecodeResult(result, error) {\n      if (result) {\n        this.dispatchScanSuccess(result);\n      } else {\n        this.dispatchScanFailure(error);\n      }\n\n      this.dispatchScanComplete(result);\n    }\n    /**\n     * Stops the code reader and returns the previous selected device.\n     */\n\n\n    _reset() {\n      if (!this._codeReader) {\n        return;\n      }\n\n      const device = this._device; // do not set this.device inside this method, it would create a recursive loop\n\n      this.device = undefined;\n      this._codeReader = undefined;\n      return device;\n    }\n    /**\n     * Resets the scanner and emits device change.\n     */\n\n\n    reset() {\n      this._reset();\n\n      this.deviceChange.emit(null);\n    }\n    /**\n     * Sets the current device.\n     */\n\n\n    setDevice(device) {\n      return __awaiter(this, void 0, void 0, function* () {\n        // instantly stops the scan before changing devices\n        this.scanStop(); // correctly sets the new (or none) device\n\n        this._device = device || undefined;\n\n        if (!this._device) {\n          // cleans the video because user removed the device\n          BrowserCodeReader.cleanVideoSource(this.previewElemRef.nativeElement);\n        } // if enabled, starts scanning\n\n\n        if (this._enabled && device) {\n          yield this.scanFromDevice(device.deviceId);\n        }\n      });\n    }\n    /**\n     * Sets the permission value and emmits the event.\n     */\n\n\n    setPermission(hasPermission) {\n      this.hasPermission = hasPermission;\n      this.permissionResponse.next(hasPermission);\n    }\n\n  }\n\n  ZXingScannerComponent.ɵfac = function ZXingScannerComponent_Factory(t) {\n    return new (t || ZXingScannerComponent)();\n  };\n\n  ZXingScannerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ZXingScannerComponent,\n    selectors: [[\"zxing-scanner\"]],\n    viewQuery: function ZXingScannerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.previewElemRef = _t.first);\n      }\n    },\n    inputs: {\n      timeBetweenScans: \"timeBetweenScans\",\n      delayBetweenScanSuccess: \"delayBetweenScanSuccess\",\n      previewFitMode: \"previewFitMode\",\n      autofocusEnabled: \"autofocusEnabled\",\n      autostart: \"autostart\",\n      formats: \"formats\",\n      device: \"device\",\n      videoConstraints: \"videoConstraints\",\n      torch: \"torch\",\n      enable: \"enable\",\n      tryHarder: \"tryHarder\"\n    },\n    outputs: {\n      autostarted: \"autostarted\",\n      autostarting: \"autostarting\",\n      torchCompatible: \"torchCompatible\",\n      scanSuccess: \"scanSuccess\",\n      scanFailure: \"scanFailure\",\n      scanError: \"scanError\",\n      scanComplete: \"scanComplete\",\n      camerasFound: \"camerasFound\",\n      camerasNotFound: \"camerasNotFound\",\n      permissionResponse: \"permissionResponse\",\n      hasDevices: \"hasDevices\",\n      deviceChange: \"deviceChange\"\n    },\n    decls: 6,\n    vars: 2,\n    consts: [[\"preview\", \"\"]],\n    template: function ZXingScannerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"video\", null, 0);\n        ɵngcc0.ɵɵelementStart(2, \"p\");\n        ɵngcc0.ɵɵtext(3, \" Your browser does not support this feature, please try to upgrade it. \");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(4, \"p\");\n        ɵngcc0.ɵɵtext(5, \" Seu navegador n\\u00E3o suporta este recurso, por favor tente atualiz\\u00E1-lo. \");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"object-fit\", ctx.previewFitMode);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}video[_ngcontent-%COMP%]{width:100%;height:auto;-o-object-fit:contain;object-fit:contain}\"],\n    changeDetection: 0\n  });\n  return ZXingScannerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ZXingScannerModule = /*#__PURE__*/(() => {\n  class ZXingScannerModule {}\n\n  ZXingScannerModule.ɵfac = function ZXingScannerModule_Factory(t) {\n    return new (t || ZXingScannerModule)();\n  };\n\n  ZXingScannerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ZXingScannerModule\n  });\n  ZXingScannerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule]]\n  });\n  return ZXingScannerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ZXingScannerModule, {\n    declarations: function () {\n      return [ZXingScannerComponent];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule];\n    },\n    exports: function () {\n      return [ZXingScannerComponent];\n    }\n  });\n})();\n/*\n * Public API Surface of zxing-scanner\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ZXingScannerComponent, ZXingScannerModule }; //# sourceMappingURL=zxing-ngx-scanner.js.map","map":null,"metadata":{},"sourceType":"module"}